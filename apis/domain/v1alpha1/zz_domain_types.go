// SPDX-FileCopyrightText: 2023 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type BootDeviceInitParameters struct {
	Dev []*string `json:"dev,omitempty" tf:"dev,omitempty"`
}

type BootDeviceObservation struct {
	Dev []*string `json:"dev,omitempty" tf:"dev,omitempty"`
}

type BootDeviceParameters struct {

	// +kubebuilder:validation:Optional
	Dev []*string `json:"dev,omitempty" tf:"dev,omitempty"`
}

type CPUInitParameters struct {
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type CPUObservation struct {
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type CPUParameters struct {

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`
}

type ConsoleInitParameters struct {
	SourceHost *string `json:"sourceHost,omitempty" tf:"source_host,omitempty"`

	SourcePath *string `json:"sourcePath,omitempty" tf:"source_path,omitempty"`

	SourceService *string `json:"sourceService,omitempty" tf:"source_service,omitempty"`

	TargetPort *string `json:"targetPort,omitempty" tf:"target_port,omitempty"`

	TargetType *string `json:"targetType,omitempty" tf:"target_type,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ConsoleObservation struct {
	SourceHost *string `json:"sourceHost,omitempty" tf:"source_host,omitempty"`

	SourcePath *string `json:"sourcePath,omitempty" tf:"source_path,omitempty"`

	SourceService *string `json:"sourceService,omitempty" tf:"source_service,omitempty"`

	TargetPort *string `json:"targetPort,omitempty" tf:"target_port,omitempty"`

	TargetType *string `json:"targetType,omitempty" tf:"target_type,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ConsoleParameters struct {

	// +kubebuilder:validation:Optional
	SourceHost *string `json:"sourceHost,omitempty" tf:"source_host,omitempty"`

	// +kubebuilder:validation:Optional
	SourcePath *string `json:"sourcePath,omitempty" tf:"source_path,omitempty"`

	// +kubebuilder:validation:Optional
	SourceService *string `json:"sourceService,omitempty" tf:"source_service,omitempty"`

	// +kubebuilder:validation:Optional
	TargetPort *string `json:"targetPort" tf:"target_port,omitempty"`

	// +kubebuilder:validation:Optional
	TargetType *string `json:"targetType,omitempty" tf:"target_type,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type DiskInitParameters struct {
	BlockDevice *string `json:"blockDevice,omitempty" tf:"block_device,omitempty"`

	File *string `json:"file,omitempty" tf:"file,omitempty"`

	Scsi *bool `json:"scsi,omitempty" tf:"scsi,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	VolumeID *string `json:"volumeId,omitempty" tf:"volume_id,omitempty"`

	Wwn *string `json:"wwn,omitempty" tf:"wwn,omitempty"`
}

type DiskObservation struct {
	BlockDevice *string `json:"blockDevice,omitempty" tf:"block_device,omitempty"`

	File *string `json:"file,omitempty" tf:"file,omitempty"`

	Scsi *bool `json:"scsi,omitempty" tf:"scsi,omitempty"`

	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	VolumeID *string `json:"volumeId,omitempty" tf:"volume_id,omitempty"`

	Wwn *string `json:"wwn,omitempty" tf:"wwn,omitempty"`
}

type DiskParameters struct {

	// +kubebuilder:validation:Optional
	BlockDevice *string `json:"blockDevice,omitempty" tf:"block_device,omitempty"`

	// +kubebuilder:validation:Optional
	File *string `json:"file,omitempty" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Scsi *bool `json:"scsi,omitempty" tf:"scsi,omitempty"`

	// +kubebuilder:validation:Optional
	URL *string `json:"url,omitempty" tf:"url,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeID *string `json:"volumeId,omitempty" tf:"volume_id,omitempty"`

	// +kubebuilder:validation:Optional
	Wwn *string `json:"wwn,omitempty" tf:"wwn,omitempty"`
}

type DomainInitParameters struct {
	Arch *string `json:"arch,omitempty" tf:"arch,omitempty"`

	Autostart *bool `json:"autostart,omitempty" tf:"autostart,omitempty"`

	BootDevice []BootDeviceInitParameters `json:"bootDevice,omitempty" tf:"boot_device,omitempty"`

	CPU []CPUInitParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	Cmdline []map[string]*string `json:"cmdline,omitempty" tf:"cmdline,omitempty"`

	Console []ConsoleInitParameters `json:"console,omitempty" tf:"console,omitempty"`

	CoreosIgnition *string `json:"coreosIgnition,omitempty" tf:"coreos_ignition,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	Disk []DiskInitParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	Emulator *string `json:"emulator,omitempty" tf:"emulator,omitempty"`

	Filesystem []FilesystemInitParameters `json:"filesystem,omitempty" tf:"filesystem,omitempty"`

	Firmware *string `json:"firmware,omitempty" tf:"firmware,omitempty"`

	FwCfgName *string `json:"fwCfgName,omitempty" tf:"fw_cfg_name,omitempty"`

	Graphics []GraphicsInitParameters `json:"graphics,omitempty" tf:"graphics,omitempty"`

	Initrd *string `json:"initrd,omitempty" tf:"initrd,omitempty"`

	Kernel *string `json:"kernel,omitempty" tf:"kernel,omitempty"`

	Machine *string `json:"machine,omitempty" tf:"machine,omitempty"`

	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	Metadata *string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NetworkInterface []NetworkInterfaceInitParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	Nvram []NvramInitParameters `json:"nvram,omitempty" tf:"nvram,omitempty"`

	QemuAgent *bool `json:"qemuAgent,omitempty" tf:"qemu_agent,omitempty"`

	Running *bool `json:"running,omitempty" tf:"running,omitempty"`

	Tpm []TpmInitParameters `json:"tpm,omitempty" tf:"tpm,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	Vcpu *float64 `json:"vcpu,omitempty" tf:"vcpu,omitempty"`

	Video []VideoInitParameters `json:"video,omitempty" tf:"video,omitempty"`

	XML []XMLInitParameters `json:"xml,omitempty" tf:"xml,omitempty"`
}

type DomainObservation struct {
	Arch *string `json:"arch,omitempty" tf:"arch,omitempty"`

	Autostart *bool `json:"autostart,omitempty" tf:"autostart,omitempty"`

	BootDevice []BootDeviceObservation `json:"bootDevice,omitempty" tf:"boot_device,omitempty"`

	CPU []CPUObservation `json:"cpu,omitempty" tf:"cpu,omitempty"`

	Cloudinit *string `json:"cloudinit,omitempty" tf:"cloudinit,omitempty"`

	Cmdline []map[string]*string `json:"cmdline,omitempty" tf:"cmdline,omitempty"`

	Console []ConsoleObservation `json:"console,omitempty" tf:"console,omitempty"`

	CoreosIgnition *string `json:"coreosIgnition,omitempty" tf:"coreos_ignition,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	Disk []DiskObservation `json:"disk,omitempty" tf:"disk,omitempty"`

	Emulator *string `json:"emulator,omitempty" tf:"emulator,omitempty"`

	Filesystem []FilesystemObservation `json:"filesystem,omitempty" tf:"filesystem,omitempty"`

	Firmware *string `json:"firmware,omitempty" tf:"firmware,omitempty"`

	FwCfgName *string `json:"fwCfgName,omitempty" tf:"fw_cfg_name,omitempty"`

	Graphics []GraphicsObservation `json:"graphics,omitempty" tf:"graphics,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Initrd *string `json:"initrd,omitempty" tf:"initrd,omitempty"`

	Kernel *string `json:"kernel,omitempty" tf:"kernel,omitempty"`

	Machine *string `json:"machine,omitempty" tf:"machine,omitempty"`

	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	Metadata *string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	NetworkInterface []NetworkInterfaceObservation `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	Nvram []NvramObservation `json:"nvram,omitempty" tf:"nvram,omitempty"`

	QemuAgent *bool `json:"qemuAgent,omitempty" tf:"qemu_agent,omitempty"`

	Running *bool `json:"running,omitempty" tf:"running,omitempty"`

	Tpm []TpmObservation `json:"tpm,omitempty" tf:"tpm,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	Vcpu *float64 `json:"vcpu,omitempty" tf:"vcpu,omitempty"`

	Video []VideoObservation `json:"video,omitempty" tf:"video,omitempty"`

	XML []XMLObservation `json:"xml,omitempty" tf:"xml,omitempty"`
}

type DomainParameters struct {

	// +kubebuilder:validation:Optional
	Arch *string `json:"arch,omitempty" tf:"arch,omitempty"`

	// +kubebuilder:validation:Optional
	Autostart *bool `json:"autostart,omitempty" tf:"autostart,omitempty"`

	// +kubebuilder:validation:Optional
	BootDevice []BootDeviceParameters `json:"bootDevice,omitempty" tf:"boot_device,omitempty"`

	// +kubebuilder:validation:Optional
	CPU []CPUParameters `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +crossplane:generate:reference:type=github.com/nourspeed/provider-libvirt/apis/cloudinit/v1alpha1.Disk
	// +kubebuilder:validation:Optional
	Cloudinit *string `json:"cloudinit,omitempty" tf:"cloudinit,omitempty"`

	// Reference to a Disk in cloudinit to populate cloudinit.
	// +kubebuilder:validation:Optional
	CloudinitRef *v1.Reference `json:"cloudinitRef,omitempty" tf:"-"`

	// Selector for a Disk in cloudinit to populate cloudinit.
	// +kubebuilder:validation:Optional
	CloudinitSelector *v1.Selector `json:"cloudinitSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	Cmdline []map[string]*string `json:"cmdline,omitempty" tf:"cmdline,omitempty"`

	// +kubebuilder:validation:Optional
	Console []ConsoleParameters `json:"console,omitempty" tf:"console,omitempty"`

	// +kubebuilder:validation:Optional
	CoreosIgnition *string `json:"coreosIgnition,omitempty" tf:"coreos_ignition,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Disk []DiskParameters `json:"disk,omitempty" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	Emulator *string `json:"emulator,omitempty" tf:"emulator,omitempty"`

	// +kubebuilder:validation:Optional
	Filesystem []FilesystemParameters `json:"filesystem,omitempty" tf:"filesystem,omitempty"`

	// +kubebuilder:validation:Optional
	Firmware *string `json:"firmware,omitempty" tf:"firmware,omitempty"`

	// +kubebuilder:validation:Optional
	FwCfgName *string `json:"fwCfgName,omitempty" tf:"fw_cfg_name,omitempty"`

	// +kubebuilder:validation:Optional
	Graphics []GraphicsParameters `json:"graphics,omitempty" tf:"graphics,omitempty"`

	// +kubebuilder:validation:Optional
	Initrd *string `json:"initrd,omitempty" tf:"initrd,omitempty"`

	// +kubebuilder:validation:Optional
	Kernel *string `json:"kernel,omitempty" tf:"kernel,omitempty"`

	// +kubebuilder:validation:Optional
	Machine *string `json:"machine,omitempty" tf:"machine,omitempty"`

	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// +kubebuilder:validation:Optional
	Metadata *string `json:"metadata,omitempty" tf:"metadata,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkInterface []NetworkInterfaceParameters `json:"networkInterface,omitempty" tf:"network_interface,omitempty"`

	// +kubebuilder:validation:Optional
	Nvram []NvramParameters `json:"nvram,omitempty" tf:"nvram,omitempty"`

	// +kubebuilder:validation:Optional
	QemuAgent *bool `json:"qemuAgent,omitempty" tf:"qemu_agent,omitempty"`

	// +kubebuilder:validation:Optional
	Running *bool `json:"running,omitempty" tf:"running,omitempty"`

	// +kubebuilder:validation:Optional
	Tpm []TpmParameters `json:"tpm,omitempty" tf:"tpm,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	Vcpu *float64 `json:"vcpu,omitempty" tf:"vcpu,omitempty"`

	// +kubebuilder:validation:Optional
	Video []VideoParameters `json:"video,omitempty" tf:"video,omitempty"`

	// +kubebuilder:validation:Optional
	XML []XMLParameters `json:"xml,omitempty" tf:"xml,omitempty"`
}

type FilesystemInitParameters struct {
	Accessmode *string `json:"accessmode,omitempty" tf:"accessmode,omitempty"`

	Readonly *bool `json:"readonly,omitempty" tf:"readonly,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type FilesystemObservation struct {
	Accessmode *string `json:"accessmode,omitempty" tf:"accessmode,omitempty"`

	Readonly *bool `json:"readonly,omitempty" tf:"readonly,omitempty"`

	Source *string `json:"source,omitempty" tf:"source,omitempty"`

	Target *string `json:"target,omitempty" tf:"target,omitempty"`
}

type FilesystemParameters struct {

	// +kubebuilder:validation:Optional
	Accessmode *string `json:"accessmode,omitempty" tf:"accessmode,omitempty"`

	// +kubebuilder:validation:Optional
	Readonly *bool `json:"readonly,omitempty" tf:"readonly,omitempty"`

	// +kubebuilder:validation:Optional
	Source *string `json:"source" tf:"source,omitempty"`

	// +kubebuilder:validation:Optional
	Target *string `json:"target" tf:"target,omitempty"`
}

type GraphicsInitParameters struct {
	Autoport *bool `json:"autoport,omitempty" tf:"autoport,omitempty"`

	ListenAddress *string `json:"listenAddress,omitempty" tf:"listen_address,omitempty"`

	ListenType *string `json:"listenType,omitempty" tf:"listen_type,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	Websocket *float64 `json:"websocket,omitempty" tf:"websocket,omitempty"`
}

type GraphicsObservation struct {
	Autoport *bool `json:"autoport,omitempty" tf:"autoport,omitempty"`

	ListenAddress *string `json:"listenAddress,omitempty" tf:"listen_address,omitempty"`

	ListenType *string `json:"listenType,omitempty" tf:"listen_type,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	Websocket *float64 `json:"websocket,omitempty" tf:"websocket,omitempty"`
}

type GraphicsParameters struct {

	// +kubebuilder:validation:Optional
	Autoport *bool `json:"autoport,omitempty" tf:"autoport,omitempty"`

	// +kubebuilder:validation:Optional
	ListenAddress *string `json:"listenAddress,omitempty" tf:"listen_address,omitempty"`

	// +kubebuilder:validation:Optional
	ListenType *string `json:"listenType,omitempty" tf:"listen_type,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// +kubebuilder:validation:Optional
	Websocket *float64 `json:"websocket,omitempty" tf:"websocket,omitempty"`
}

type NetworkInterfaceInitParameters struct {
	Addresses []*string `json:"addresses,omitempty" tf:"addresses,omitempty"`

	Bridge *string `json:"bridge,omitempty" tf:"bridge,omitempty"`

	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	Mac *string `json:"mac,omitempty" tf:"mac,omitempty"`

	Macvtap *string `json:"macvtap,omitempty" tf:"macvtap,omitempty"`

	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	NetworkName *string `json:"networkName,omitempty" tf:"network_name,omitempty"`

	Passthrough *string `json:"passthrough,omitempty" tf:"passthrough,omitempty"`

	Vepa *string `json:"vepa,omitempty" tf:"vepa,omitempty"`

	WaitForLease *bool `json:"waitForLease,omitempty" tf:"wait_for_lease,omitempty"`
}

type NetworkInterfaceObservation struct {
	Addresses []*string `json:"addresses,omitempty" tf:"addresses,omitempty"`

	Bridge *string `json:"bridge,omitempty" tf:"bridge,omitempty"`

	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	Mac *string `json:"mac,omitempty" tf:"mac,omitempty"`

	Macvtap *string `json:"macvtap,omitempty" tf:"macvtap,omitempty"`

	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	NetworkName *string `json:"networkName,omitempty" tf:"network_name,omitempty"`

	Passthrough *string `json:"passthrough,omitempty" tf:"passthrough,omitempty"`

	Vepa *string `json:"vepa,omitempty" tf:"vepa,omitempty"`

	WaitForLease *bool `json:"waitForLease,omitempty" tf:"wait_for_lease,omitempty"`
}

type NetworkInterfaceParameters struct {

	// +kubebuilder:validation:Optional
	Addresses []*string `json:"addresses,omitempty" tf:"addresses,omitempty"`

	// +kubebuilder:validation:Optional
	Bridge *string `json:"bridge,omitempty" tf:"bridge,omitempty"`

	// +kubebuilder:validation:Optional
	Hostname *string `json:"hostname,omitempty" tf:"hostname,omitempty"`

	// +kubebuilder:validation:Optional
	Mac *string `json:"mac,omitempty" tf:"mac,omitempty"`

	// +kubebuilder:validation:Optional
	Macvtap *string `json:"macvtap,omitempty" tf:"macvtap,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkID *string `json:"networkId,omitempty" tf:"network_id,omitempty"`

	// +kubebuilder:validation:Optional
	NetworkName *string `json:"networkName,omitempty" tf:"network_name,omitempty"`

	// +kubebuilder:validation:Optional
	Passthrough *string `json:"passthrough,omitempty" tf:"passthrough,omitempty"`

	// +kubebuilder:validation:Optional
	Vepa *string `json:"vepa,omitempty" tf:"vepa,omitempty"`

	// +kubebuilder:validation:Optional
	WaitForLease *bool `json:"waitForLease,omitempty" tf:"wait_for_lease,omitempty"`
}

type NvramInitParameters struct {
	File *string `json:"file,omitempty" tf:"file,omitempty"`

	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type NvramObservation struct {
	File *string `json:"file,omitempty" tf:"file,omitempty"`

	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type NvramParameters struct {

	// +kubebuilder:validation:Optional
	File *string `json:"file" tf:"file,omitempty"`

	// +kubebuilder:validation:Optional
	Template *string `json:"template,omitempty" tf:"template,omitempty"`
}

type TpmInitParameters struct {
	BackendDevicePath *string `json:"backendDevicePath,omitempty" tf:"backend_device_path,omitempty"`

	BackendEncryptionSecret *string `json:"backendEncryptionSecret,omitempty" tf:"backend_encryption_secret,omitempty"`

	BackendPersistentState *bool `json:"backendPersistentState,omitempty" tf:"backend_persistent_state,omitempty"`

	BackendType *string `json:"backendType,omitempty" tf:"backend_type,omitempty"`

	BackendVersion *string `json:"backendVersion,omitempty" tf:"backend_version,omitempty"`

	Model *string `json:"model,omitempty" tf:"model,omitempty"`
}

type TpmObservation struct {
	BackendDevicePath *string `json:"backendDevicePath,omitempty" tf:"backend_device_path,omitempty"`

	BackendEncryptionSecret *string `json:"backendEncryptionSecret,omitempty" tf:"backend_encryption_secret,omitempty"`

	BackendPersistentState *bool `json:"backendPersistentState,omitempty" tf:"backend_persistent_state,omitempty"`

	BackendType *string `json:"backendType,omitempty" tf:"backend_type,omitempty"`

	BackendVersion *string `json:"backendVersion,omitempty" tf:"backend_version,omitempty"`

	Model *string `json:"model,omitempty" tf:"model,omitempty"`
}

type TpmParameters struct {

	// +kubebuilder:validation:Optional
	BackendDevicePath *string `json:"backendDevicePath,omitempty" tf:"backend_device_path,omitempty"`

	// +kubebuilder:validation:Optional
	BackendEncryptionSecret *string `json:"backendEncryptionSecret,omitempty" tf:"backend_encryption_secret,omitempty"`

	// +kubebuilder:validation:Optional
	BackendPersistentState *bool `json:"backendPersistentState,omitempty" tf:"backend_persistent_state,omitempty"`

	// +kubebuilder:validation:Optional
	BackendType *string `json:"backendType,omitempty" tf:"backend_type,omitempty"`

	// +kubebuilder:validation:Optional
	BackendVersion *string `json:"backendVersion,omitempty" tf:"backend_version,omitempty"`

	// +kubebuilder:validation:Optional
	Model *string `json:"model,omitempty" tf:"model,omitempty"`
}

type VideoInitParameters struct {
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type VideoObservation struct {
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type VideoParameters struct {

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type XMLInitParameters struct {
	Xslt *string `json:"xslt,omitempty" tf:"xslt,omitempty"`
}

type XMLObservation struct {
	Xslt *string `json:"xslt,omitempty" tf:"xslt,omitempty"`
}

type XMLParameters struct {

	// +kubebuilder:validation:Optional
	Xslt *string `json:"xslt,omitempty" tf:"xslt,omitempty"`
}

// DomainSpec defines the desired state of Domain
type DomainSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DomainParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider DomainInitParameters `json:"initProvider,omitempty"`
}

// DomainStatus defines the observed state of Domain.
type DomainStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DomainObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Domain is the Schema for the Domains API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,libvirt}
type Domain struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   DomainSpec   `json:"spec"`
	Status DomainStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DomainList contains a list of Domains
type DomainList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Domain `json:"items"`
}

// Repository type metadata.
var (
	Domain_Kind             = "Domain"
	Domain_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Domain_Kind}.String()
	Domain_KindAPIVersion   = Domain_Kind + "." + CRDGroupVersion.String()
	Domain_GroupVersionKind = CRDGroupVersion.WithKind(Domain_Kind)
)

func init() {
	SchemeBuilder.Register(&Domain{}, &DomainList{})
}
